10
A <b>recursive function</b> is a function that calls itself in its function body. Preferably it calls itself with a simpler problem to solve. 
In maths we see recursion all of the time. For example, factorial (!) is defined recursively as \nn! = n*(n-1)*(n-2)*...*2*1 = n*(n-1)!
So in the definition of factorial we call factorial but on a simpler problem as now n has been decremented. 
It is important for recursive functions to have a <b>base case</b>. This is a case that is not defined recursively and is needed in order for recursion to terminate.
The base case for factorial is 1! = 1. If we never had this case then we would start taking factorials of negative numbers which is bad as it would run forever!
Q4What is the factorial of 4?
10
*24
16
20
The factorial of 4 if 4*3*2*1 = 24. Let's have a look at how we would program factorial in Haskell and then work through it with an example.
Make a note of the following function as we are going to be working with it throughout this class.\n<align="left">factorial :: Int -> Int\nfactorial 1 = 1\nfactorial n = n * factorial (n-1)</align>
As with all functions, the first line is the type signature. The second line is the base case, where we are using pattern matching to determine if the input is 1. The final line is where the recursion happens as we call factorial inside factorial!
Now let's see how our factorial function works by calling it with 4 (/= means not equals).
<align="left">factorial 4,  <color=blue>(4/=1)</color>\n= 4*factorial (4-1),  <color=blue> (4-1=3/=1)</color>\n= 4*(3*factorial (3-1)),  <color=blue> (3-1=2/=1)</color>\n= 4*(3*(2*factorial (2-1))),  <color=blue> (2-1=1)</color>\n= 4*(3*(2*(1)))\n= 4*3*2*1=24</align>
It is also possible to have multiple base cases. A good example of this can again be found in maths, Fibonacci numbers. 
Fibonacci numbers are a sequence of numbers generated by summing the previous 2 numbers of the sequence. Because of this we need two base cases, the first two numbers of the sequence. These are 0 and 1. So the first five terms of the sequence are 0,1,1,2,3,5,...
The mathematical formula for Fibonacci number n is F(n) = F(n-1) + F(n-2). Let's have a look at its Haskell implementation. 
Again make a note of the function.\n<align="left">fib :: Int -> Int\nfib 0 = 0\nfib 1 = 1\nfib n = fib(n-1) + fib(n-2) </align>
Notice this time that we have the two base cases on lines 2 and 3. As we mentioned in pattern matching the order of these lines matter. 
For example, lets define\n<align="left">factorial2 :: Int -> Int\nfactorial2 n = n * factorial2 (n-1)\nfactorial2 1 = 1</align>\nthen...
Q4What is the output of "factorial2 4"?
1
24
16
*Stack overflow
*Well done! It will output stack overflow because the last line of the function, the base case, is never reached so the function will not terminate and the memory of the computer, the stack, will overflow.
Not quite. As the base case is under the case that catches everything it will never get executed. This means the function will never terminate so the memory of the computer, the stack, will overflow.
So the base cases always have to come before the recursive part of the function. Let's run through how fib works with an example.
<align="left">fib 4\n= fib (4-1) + fib (4-2)\n= (fib (3-1) + fib (3-2)) + (fib (2-1) + fib (2-2))\n= ((fib (2-1) + fib (2-2)) + fib 1) + (fib 1 + fib 0)\n= ((fib 1 + fib 0) + fib 1) + (fib 1 + fib 0)\n= ((1 + 0) + 1) + (1 + 0) = 3</align>
That's all for today. Next time we will cover more recursion and look at recursion on lists