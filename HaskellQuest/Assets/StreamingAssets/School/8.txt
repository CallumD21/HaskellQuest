15
Last time we looked at list comprehensions with multiple generators and today we will look at nested list comprehensions.
When I first introduced lists I said that lists can contain many different types, well this includes lists themselves.
So, we have already seen lists of integers, [Int], but we can also have a list of lists of integers, [[Int]]. 
An example is, [[1,2],[3,4]]. That is a list containing the list of integers [1,2] and the list of integers [3,4].
As we have already seen we can generate new lists from old lists using list comprehensions. Well we can generate lists of lists by using nested list comprehensions.
Let's go through an example together.
First, remember that the list generated by \n[x | x<-[1..n]] where n is some positive integer is [1,2,3,4,...,n]. Now we can use a second generator to select the value of n.
This is what a nested list comprehensions looks like\n[[x | x<-[1..n]] | n<-[1,2]]\nNow this looks horrible, so let's break it down into its pieces.
The nested list comprehension in words will generate the list of [x | x<-[1..n]] <b>where</b> n is <b>drawn from</b> [1,2].
We start in the outer list comprehension first, so we let n=1. Then we move to the inner list comprehension. As we already know, when n=1 the inner list comprehension generates the list [1] then we set n to the next value which is 2. The inner list comprehension then generates the list [1,2].
We are now finished. Putting this all together we get [[1],[1,2]].
Last class we saw the following list comprehension\n[(x,y) | x<-[1,2], y<-[3,4]]
Q4As a recap, what is the output of \n[(x,y) | x<-[1,2], y<-[3,4]]?
*[(1,3),(1,4),(2,3),(2,4)]
[(1,3),(2,3),(1,4),(2,4)]
[(3,1),(4,1),(3,2),(4,2)]
[(3,1),(3,2),(4,1),(4,2)]
*Yes! First we pair x=1 with all possible values of y so (1,3) and (1,4) then we move x onto the next value and repeat so (2,3) and (2,4).
Not quite. First we pair x with all possible values of y so (1,3) and (1,4) then we move x onto the next value and repeat so (2,3) and (2,4).
Now, the following nested list comprehension looks very similar but has very different behaviour.\n[[(x,y) | x<-[1,2]] | y<-[3,4]]
Q4What is the output of [[(x,y) | x<-[1,2]] | y<-[3,4]]?
[(1,3),(1,4),(2,3),(2,4)]
[[(1,3),(1,4)],[(2,3),(2,4)]]
*[[(1,3),(2,3)],[(1,4),(2,4)]]
[(1,3),(2,3),(1,4),(2,4)]
*Yes! First we set the value of y to 3 then pair this with all values of x so we get the <b>list</b> of pairs (1,3) and (2,3). Then the value of y gets updated to 4. Pairing this with all values of x gives the <b>list</b> of pairs (1,4) and (2,4).
Not quite. First we set the value of y to 3 then pair this with all values of x so we get the <b>list</b> of pairs (1,3) and (2,3). Then the value of y gets updated to 4. Pairing this with all values of x gives the <b>list</b> of pairs (1,4) and (2,4).
Again, understanding the order in which values are read from the generators is very important.
That's all for today and next time we will look at adding guards to list comprehensions.